# SEEDlabs: Environment Variable and Set-UID Program Lab

#### Ozgur Ural
#### Student ID: 2564455

## Lab Description

The learning objective of this lab is for students to understand how environment variables affect program
and system behaviors. Environment variables are a set of dynamic named values that can affect the way
running processes will behave on a computer. They are used by most operating systems, since they were
introduced to Unix in 1979. Although environment variables affect program behaviors, how they achieve
that is not well understood by many programmers. As a result, if a program uses environment variables, but
the programmer does not know that they are used, the program may have vulnerabilities.
In this lab, students will understand how environment variables work, how they are propagated from
parent process to child, and how they affect system/program behaviors. We are particularly interested in how
environment variables affect the behavior of Set-UID programs, which are usually privileged programs.
This lab covers the following topics:

• Environment variables
• Set-UID programs
• Securely invoke external programs
• Capability leaking
• Dynamic loader/linker


## Lab Tasks

### Task 1: Manipulating environment variables

In this task, we study the commands that can be used to set and unset environment variables. We are using Bash in the seed account. The default shell that a user uses is set in the `/etc/passwd` file (the last field of each entry). You can change this to another shell program using the command `chsh` (please do not do it for this lab). Please do the following tasks:

- Use `printenv` or `env` command to print out the environment variables. If you are interested in some particular environment variables, such as `PWD`, you can use "`printenv PWD`" or "`env | grep PWD`".
- Use `export` and `unset` to set or unset environment variables. It should be noted that these two commands are not seperate programs; they are two of the Bash's internal commands (you will not be able to find them outside of Bash).

Solution:
```c
printenv atau env
```

```sh
[09/21/22]seed@VM:~$ printenv
SHELL=/bin/bash
SESSION_MANAGER=local/VM:@/tmp/.ICE-unix/2021,unix/VM:/tmp/.ICE-unix/2021
QT_ACCESSIBILITY=1
COLORTERM=truecolor
XDG_CONFIG_DIRS=/etc/xdg/xdg-ubuntu:/etc/xdg
XDG_MENU_PREFIX=gnome-
GNOME_DESKTOP_SESSION_ID=this-is-deprecated
GNOME_SHELL_SESSION_MODE=ubuntu
SSH_AUTH_SOCK=/run/user/1000/keyring/ssh
XMODIFIERS=@im=ibus
DESKTOP_SESSION=ubuntu
SSH_AGENT_PID=1923
GTK_MODULES=gail:atk-bridge
PWD=/home/seed
LOGNAME=seed
XDG_SESSION_DESKTOP=ubuntu
XDG_SESSION_TYPE=x11
GPG_AGENT_INFO=/run/user/1000/gnupg/S.gpg-agent:0:1
XAUTHORITY=/run/user/1000/gdm/Xauthority
GJS_DEBUG_TOPICS=JS ERROR;JS LOG
WINDOWPATH=2
HOME=/home/seed
USERNAME=seed
IM_CONFIG_PHASE=1
LANG=en_US.UTF-8
LS_COLORS=rs=0:di=01;34:ln=01;36:mh=00:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:mi=00:su=37;41:sg=30;43:ca=30;41:tw=30;42:ow=34;42:st=37;44:ex=01;32:*.tar=01;31:*.tgz=01;31:*.arc=01;31:*.arj=01;31:*.taz=01;31:*.lha=01;31:*.lz4=01;31:*.lzh=01;31:*.lzma=01;31:*.tlz=01;31:*.txz=01;31:*.tzo=01;31:*.t7z=01;31:*.zip=01;31:*.z=01;31:*.dz=01;31:*.gz=01;31:*.lrz=01;31:*.lz=01;31:*.lzo=01;31:*.xz=01;31:*.zst=01;31:*.tzst=01;31:*.bz2=01;31:*.bz=01;31:*.tbz=01;31:*.tbz2=01;31:*.tz=01;31:*.deb=01;31:*.rpm=01;31:*.jar=01;31:*.war=01;31:*.ear=01;31:*.sar=01;31:*.rar=01;31:*.alz=01;31:*.ace=01;31:*.zoo=01;31:*.cpio=01;31:*.7z=01;31:*.rz=01;31:*.cab=01;31:*.wim=01;31:*.swm=01;31:*.dwm=01;31:*.esd=01;31:*.jpg=01;35:*.jpeg=01;35:*.mjpg=01;35:*.mjpeg=01;35:*.gif=01;35:*.bmp=01;35:*.pbm=01;35:*.pgm=01;35:*.ppm=01;35:*.tga=01;35:*.xbm=01;35:*.xpm=01;35:*.tif=01;35:*.tiff=01;35:*.png=01;35:*.svg=01;35:*.svgz=01;35:*.mng=01;35:*.pcx=01;35:*.mov=01;35:*.mpg=01;35:*.mpeg=01;35:*.m2v=01;35:*.mkv=01;35:*.webm=01;35:*.ogm=01;35:*.mp4=01;35:*.m4v=01;35:*.mp4v=01;35:*.vob=01;35:*.qt=01;35:*.nuv=01;35:*.wmv=01;35:*.asf=01;35:*.rm=01;35:*.rmvb=01;35:*.flc=01;35:*.avi=01;35:*.fli=01;35:*.flv=01;35:*.gl=01;35:*.dl=01;35:*.xcf=01;35:*.xwd=01;35:*.yuv=01;35:*.cgm=01;35:*.emf=01;35:*.ogv=01;35:*.ogx=01;35:*.aac=00;36:*.au=00;36:*.flac=00;36:*.m4a=00;36:*.mid=00;36:*.midi=00;36:*.mka=00;36:*.mp3=00;36:*.mpc=00;36:*.ogg=00;36:*.ra=00;36:*.wav=00;36:*.oga=00;36:*.opus=00;36:*.spx=00;36:*.xspf=00;36:
XDG_CURRENT_DESKTOP=ubuntu:GNOME
VTE_VERSION=6003
GNOME_TERMINAL_SCREEN=/org/gnome/Terminal/screen/673e95a5_4e63_497d_9fe2_96d2cc7096d7
INVOCATION_ID=984e1ccf99f94112b8adcbe4a2225d67
MANAGERPID=1668
GJS_DEBUG_OUTPUT=stderr
LESSCLOSE=/usr/bin/lesspipe %s %s
XDG_SESSION_CLASS=user
TERM=xterm-256color
LESSOPEN=| /usr/bin/lesspipe %s
USER=seed
GNOME_TERMINAL_SERVICE=:1.104
DISPLAY=:0
SHLVL=1
QT_IM_MODULE=ibus
XDG_RUNTIME_DIR=/run/user/1000
JOURNAL_STREAM=9:33590
XDG_DATA_DIRS=/usr/share/ubuntu:/usr/local/share/:/usr/share/:/var/lib/snapd/desktop
PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin:.
GDMSESSION=ubuntu
DBUS_SESSION_BUS_ADDRESS=unix:path=/run/user/1000/bus
_=/usr/bin/printenv
```

To add we can use the command:

export
and to remove:

unset

```sh
[09/21/22]seed@VM:~$ export LOG=Ozgur
[09/21/22]seed@VM:~$ env | grep LOG
LOGNAME=seed
LOG=Ozgur
GJS_DEBUG_TOPICS=JS ERROR;JS LOG
[09/21/22]seed@VM:~$ unset LOG
[09/21/22]seed@VM:~$ env | grep LOG
LOGNAME=seed
GJS_DEBUG_TOPICS=JS ERROR;JS LOG
[09/21/22]seed@VM:~$ 
```



### Task 2: Inheriting environment variables from parents

In this task, we study how environment variables are inherited by child processes from their parents. In Unix, `fork()` creates a new process by duplicating the calling process. The new process, referred to as the child, is an exact duplicate of the calling process, referred to as the parent; however, several things are not inherited by the child (please see the manual of fork() by typing the following command: `man fork`). In this task, we would like to know whether the parent’s environment variables are inherited by the child process or not.

### Step 1

The output contains many strings, you should save the output into a file, such as using `a.out > child` (assuming that `a.out` is your executable file name).

```c
#include<unistd.h>
#include<stdio.h>
#include<stdlib.h>

extern char **environ;

void printenv()
{
    int i = 0;
    while(environ[i] != NULL) {
        printf("%s\n", environ[i]);
        i++;
    }
}

void main()
{
    pid_t childPid;
    
    switch(childPid = fork()) {
        case 0:    // child process
            printenv();
            exit(0);
        default:   // parent process
            // printenv();
            exit(0);
    }
}
```

Solution:
```sh
[09/21/22]seed@VM:~$ vim step1.c
[09/21/22]seed@VM:~$ gcc step1.c -o step1
[09/21/22]seed@VM:~$ ./step1 > res.out
[09/21/22]seed@VM:~$ cat res.out
SHELL=/bin/bash
SESSION_MANAGER=local/VM:@/tmp/.ICE-unix/2021,unix/VM:/tmp/.ICE-unix/2021
QT_ACCESSIBILITY=1
COLORTERM=truecolor
XDG_CONFIG_DIRS=/etc/xdg/xdg-ubuntu:/etc/xdg
XDG_MENU_PREFIX=gnome-
GNOME_DESKTOP_SESSION_ID=this-is-deprecated
GNOME_SHELL_SESSION_MODE=ubuntu
SSH_AUTH_SOCK=/run/user/1000/keyring/ssh
XMODIFIERS=@im=ibus
DESKTOP_SESSION=ubuntu
```

### Step 2

Now comment out the `printenv()` statement in the child process case, and uncomment the `printenv()` statement in the parent process case. Compile and run the code, and describe your observation. Save the output in another file.

Solution:
My observation: in step 1 we display the environment on the child process and in step 2 we display the environment on the parent process.

### Step 3

Compare the difference of these two files using the `diff` command.

```sh
seed@ubuntu:~/Desktop$ ./test > child
seed@ubuntu:~/Desktop$ ./test1 > child1 
seed@ubuntu:~/Desktop$ diff child child1 
36c36
< _=./test
---
> _=./test1
```

Solution:
```sh
< _=./step1
---
> _=./step2
```

Conclusion: The output result is the same, the environment variable of the parent-child process is the same, the child process will completely inherit the environment variable of the parent process.

## Task 3: Environment variables and execve()

In this task, we study how environment variables are affected when a new program is executed via `execve()`. The function `execve()` calls a system call to load a new command and execute it; this function never returns. No new process is created; instead, the calling process's text, data, bss, and stack are overwritten by that of the program loaded. Essentially, `execve()` runs the new program inside the calling process. We are interested in what happens to the environment variables; are they automatically inherited by the new program?

### Step 1

Please compile and run the following program, and describe your observation. This program simply execute a program call `/usr/bin/env`, which prints out the environment variables of the current process.

```c
#include<stdio.h>
#include<stdlib.h>

extern char **environ;

int main()
{
    char *argv[2];
    
    argv[0] = "/usr/bin/env";
    argv[1] = NULL;
    
    execve("/usr/bin/env", argv, NULL);
    
    return 0;
}
```
Solution:

```sh
[09/21/22]seed@VM:~$ vim task3.c
[09/21/22]seed@VM:~$ gcc task3.c -o task3
task3.c: In function ‘main’:
task3.c:13:5: warning: implicit declaration of function ‘execve’ [-Wimplicit-function-declaration]
   13 |     execve("/usr/bin/env", argv, NULL);
      |     ^~~~~~
[09/21/22]seed@VM:~$ ./task3
[09/21/22]seed@VM:~$ 
```
** Result : No output

### Step 2

Now, change the invocation of `execve()` to the following, and describe your observation.

```sh
execve("/usr/bin/env", argv, environ);
```

The result:

```sh
[09/21/22]seed@VM:~$ cp task3.c task3_1.c
[09/21/22]seed@VM:~$ vim task3
task3      task3_1.c  task3.c    
[09/21/22]seed@VM:~$ vim task3_1.c 
[09/21/22]seed@VM:~$ gcc task3_1.c -o task3_1
task3_1.c: In function ‘main’:
task3_1.c:13:5: warning: implicit declaration of function ‘execve’ [-Wimplicit-function-declaration]
   13 |     execve("/usr/bin/env", argv, environ);
      |     ^~~~~~
[09/21/22]seed@VM:~$ ./task3_1 
SHELL=/bin/bash
SESSION_MANAGER=local/VM:@/tmp/.ICE-unix/2021,unix/VM:/tmp/.ICE-unix/2021
QT_ACCESSIBILITY=1
COLORTERM=truecolor
XDG_CONFIG_DIRS=/etc/xdg/xdg-ubuntu:/etc/xdg
XDG_MENU_PREFIX=gnome-
GNOME_DESKTOP_SESSION_ID=this-is-deprecated
GNOME_SHELL_SESSION_MODE=ubuntu
SSH_AUTH_SOCK=/run/user/1000/keyring/ssh
```

the result comes out environment variable

Explanation: after reading man execve, there are 3 parameters in execve, namely:

```c
int execve(const char *filename, char *const argv[],
char *const envp[]);
```

** when envp[] is null, nothing is displayed. but when envp[] is filled with environ, it shows all envriontment.
```c
extern char **environ;
```
means that the code above loads the environment variable and executes it with execve , and the env cannot be called directly without loading the environment variable.


## Task 4: Environment variables and system()

In this task, we study how environment variables are affected when a new program is executed via  the `system()` function. This function is used to execute a command, but unlike `execve()`, which directly execute a command, `system()` actually executes "`/bin/sh -c command`", i.e., it executes `/bin/sh`, and asks the shell to execute the command.

If you look at the implementation of the `system()` function, you will see that it uses `execl()` to execute `/bin/sh`; `excel()` calls `execve()`, passing to it the environment variables array. Therefore, using `system()`, the environment variables of the calling process is passed to the new program `/bin/sh`.

```c
#include<stdio.h>
#include<stdlib.h>

int main()
{
    system("/usr/bin/env");
    
    return 0;
}
```

Solution:

```sh
[09/21/22]seed@VM:~$ vim task4.c
[09/21/22]seed@VM:~$ gcc task4.c -o task4
[09/21/22]seed@VM:~$ ./task4
GJS_DEBUG_TOPICS=JS ERROR;JS LOG
LESSOPEN=| /usr/bin/lesspipe %s
USER=seed
SSH_AGENT_PID=1923
XDG_SESSION_TYPE=x11
SHLVL=1
HOME=/home/seed
DESKTOP_SESSION=ubuntu
GNOME_SHELL_SESSION_MODE=ubuntu
GTK_MODULES=gail:atk-bridge
MANAGERPID=1668
DBUS_SESSION_BUS_ADDRESS=unix:path=/run/user/1000/bus
COLORTERM=truecolor
IM_CONFIG_PHASE=1
```

## Task 5: Environment variable and Set-UID Programs

Set-UID is an important security mechanism in Unix operating systems. When a Set-UID program runs, it assumes the owner's privileges. For example, if the program's owner is root, then when anyone runs this program, the program gains the root's privileges during its execution. Set-UID allows us to do many interesting things, but it escalates the user's privilege when executed, making it quite risky. Although the behaviors of Set-UID programs are decided by their program logic, not by users, users can indeed affect the behaviors via environment variables. To understand how Set-UID programs are affected, let us first figure out whether environment variables are inherited by the Set-UID program's process from the user's process.

### Step 1

We are going to write a program that can print out all the environment variables in the current process.

```c
#include<stdio.h>
#include<stdlib.h>

extern char **environ;

void main()
{
    int i = 0;
    while(environ[i] != NULL) {
        printf("%s\n", environ[i]);
        i++;
    }
}
```

### Step 2

Compile the above program, change its ownship to root, and make it a Set-UID program.

```sh
[09/21/22]seed@VM:~$ vim task5.c
[09/21/22]seed@VM:~$ gcc task5.c -o task5
[09/21/22]seed@VM:~$ sudo chown root task5
[09/21/22]seed@VM:~$ sudo chmod 4755 task5
[09/21/22]seed@VM:~$ 
```

### Step 3

In your Bash shell (use a normal account, not the root account), use the `export` command to set the following environment variables (they may have already exist):

- PATH
- LD_LIBRARY_PATH
- ANY_NAME (this is an environment variable defined by you, so pick whatever name you want).

These environment variables are set in the user's shell process. Now, run the Set-UID program from Step 2 in your shell. After you type the name of the program in your shell, the shell forks a child process, and uses the child process to run the program. Please check whether all the environment variables you set in the shell process (parent) get into the Set-UID child process.

Solution:

```sh
[09/21/22]seed@VM:~$ vim task5.c 
[09/21/22]seed@VM:~$ gcc -o task5 task5.c
[09/21/22]seed@VM:~$  chmod u+s task5
[09/21/22]seed@VM:~$ exit
exit
[09/21/22]seed@VM:~$ export MY_ENV="my env"
[09/21/22]seed@VM:~$  export PATH="my env":$PATH
[09/21/22]seed@VM:~$  ./task5 | grep "my env"
PATH=my env:.:/usr/lib/lightdm/lightdm:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games
MY_ENV=my env
```

Yes, the env that we set in the parent process is successfully entered in the set-UID of the child process.

## Task 6: The PATH Environment variable and Set-UID Programs

Because of the shell program invoked, calling `system()` within a Set-UID program is quite dangerous. This is because the actual behavior of the shell program can be affected by environment variables, such as `PATH`; these environment variables are provided by the user, who may be malicious. By changing these variables, malicious users can control the behavior of the Set-UID program. In `Bash`, you can change the `PATH` environment variable in the following way (this example adds the directory `/home/seed` to the beginning of the `PATH` environment variable):

```sh
export PATH=/home/seed:$PATH
```

The Set-UID program below is supposed to execute the `/bin/ls` command; however, the programmer only uses the relative path for the `ls` command, rather than the absolute path:

```c
int main()
{
    system("ls");
    return 0;
}
```

Compile the above program, and change its owner to root, and make it a Set-UID program. Can you let this Set-UID program run your code instead of `/bin/ls`? If you can, is your code running with the root privilege?

The solution:

```sh
[09/21/22]seed@VM:~$  vim task6.c
[09/21/22]seed@VM:~$  gcc -o task6 task6.c
[09/21/22]seed@VM:~$  chmod u+s task6
[09/21/22]seed@VM:~$  exit
exit
[09/21/22]seed@VM:~$ ./task6 
Desktop		  openssl-1.0.1				   task6
Documents	  openssl_1.0.1-4ubuntu5.11.debian.tar.gz  task6.c
```
Yes it can, set-uid can run the program /bin/ls with a relative path, for root privileges no, in task 6 it has been explained in the note for ubuntu. When we run set-uid the program will be countermeasure we can't run it which theoretically can get root privileges, to be able to run set-uid with root privileges, SEEDlabs has provided a shell program called zsh to replace /bin/sh.

to be able to run the set-UID program:
we link /bin/sh to /bin/zsh

```sh
[09/21/22]seed@VM:~$  rm /bin/sh
[09/21/22]seed@VM:~$  ln -s zsh sh
```

we try to run the ls program above with zsh

```sh
[09/21/22]root@VM:/tmp#  vim ls.c
[09/21/22]root@VM:/tmp#  gcc ls.c -o system
```

```sh
[09/21/22]seed@VM:/tmp# cp /bin/sh /tmp/ls
[09/21/22]seed@VM:/tmp# ./system
ls
ls.c
system
```
with zsh shell we can get root shell, but with native shell of ubuntu we can't get root shell.


## Task 7: The LD_PRELOAD environment variable and Set-UID Programs

In this task, we study how Set-UID programs deal with some of the environment variables. Several environment variables, including `LD_PRELOAD`, `LD_LIBRARY_PATH`, and other `LD_*` influence the behavior of dynamic loader/linker. A dynamic loader/linker is the part of an operating system (OS) that loads (from persistent storage to RAM) and links the shared libraries needed by an executable at run time.

In Linux, `ld.so` or `ld-linux.so`, are the dynamic loader/linker (each for different types of binary). Among the environment variables that affect their behaviors, `LD_LIBRARY_PATH` and `LD_PRELOAD` are the two that we are concered in this lab. In Linux, `LD_LIBRARY_PATH` is a colon-separated set of directories where libraries should be searched for first, before the standard set of directories. `LD_PRELOAD` specifies a list of additional, user-specified, shared libraries to be loaded before all others. In this task, we will only study `LD_PRELOAD`.

### Step 1

First, we will see how these environment variable influence the behavior of dynamic loader/linker overrides the `sleep()` function in `libc`:

(1) Let us build a dynamic link library. Create the following program, and name it `mylib.c`. It basically overrides the `sleep()` function in `libc`:

```c
#include<stdio.h>
void sleep(int s)
{
    // If this is invoked by a privileged program, you can do damages here!
    printf("I am not sleeping!\n");
}
```

(2) We can compile the program using the following commands:

```sh
gcc -fPIC -g -c mylib.c
gcc -shared -o libmylib.so.1.0.1 mylib.o -lc
```

(3) Now, set the `LD_PRELOAD` environment variable:

```sh
export LD_PRELOAD=./libmylib.so.1.0.1
```

(4) Finally, compile the following program `myprog`, and it in the same directory as the above dynamic link library `libmylib.so.1.0.1`:

```c
//myprog.c
int main()
{
    sleep(1);
    return 0;
}
```

Solution:
```sh
[09/21/22]seed@VM:~$ vim mylib.c
[09/21/22]seed@VM:~$ vim mylib.c
[09/21/22]seed@VM:~$ gcc -fPIC -g -c mylib.c
[09/21/22]seed@VM:~$ gcc -shared -o libmylib.so.1.0.1 mylib.o -lc
[09/21/22]seed@VM:~$ export LD_PRELOAD=./libmylib.so.1.0.1
[09/21/22]seed@VM:~$ vim myprog.c
[09/21/22]seed@VM:~$ gcc myprog.c -o myprog
myprog.c: In function ‘main’:
myprog.c:4:5: warning: implicit declaration of function ‘sleep’ [-Wimplicit-function-declaration]
    4 |     sleep(1);
      |     ^~~~~
[09/21/22]seed@VM:~$
```

```sh
[09/21/22]seed@VM:~$ ./myprog
I am not sleeping!
```


### Step 2

After you have done the above, please run `myprog` under the following conditions, and observe what happens.

- Make myprog a regular program, and run it as a normal user.

```sh
[09/21/22]seed@VM:~$ ./myprog
I am not sleeping!
```

- Make myprog a Set-UID root program, and run it as a normal user.
```sh
[09/21/22]seed@VM:~$ sudo chown root myprog
[09/21/22]seed@VM:~$ sudo chmod 4755 myprog
[09/21/22]seed@VM:~$ ./myprog 
[09/21/22]seed@VM:~$ sudo chown seed myprog
[09/21/22]seed@VM:~$ ./myprog 
I am not sleeping!
```

If the program owner is changed to root, sleep works, if the owner is changed to seed, the sleep injection is successful, indicating a different env

- Make myprog a Set-UID root program, export the LD_PRELOAD environment variable again in the root account and run it.
```sh
[09/21/22]seed@VM:~$ sudo su
root@VM:/home/seed# chown root myprog
root@VM:/home/seed# chmod 4755 myprog
root@VM:/home/seed# export LD_PRELOAD=./libmylib.so.1.0.1
root@VM:/home/seed# ./myprog
I am not sleeping!
```

- Make myprog a Set-UID user1 program (i.e., the owner is user1, which is another user account), export the `LD_PRELOAD` environment variable again in a different user's account (not-root user) and run it.

```sh
root@VM:/home/seed# sudo adduser ozgur
Adding user `ozgur' ...
Adding new group `ozgur' (1001) ...
Adding new user `ozgur' (1001) with group `ozgur' ...
Creating home directory `/home/ozgur' ...
Copying files from `/etc/skel' ...
New password: 
Retype new password: 
passwd: password updated successfully
Changing the user information for ozgur
Enter the new value, or press ENTER for the default
	Full Name []: 
	Room Number []: 
	Work Phone []: 
	Home Phone []: 
	Other []: 
Is the information correct? [Y/n] y
root@VM:/home/seed# sudo chown ozgur myprog
root@VM:/home/seed# su ozgur
ozgur@VM:/home/seed$ export LD_PRELOAD=./libmylib.so.1.0.1
ozgur@VM:/home/seed$ ./myprog
I am not sleeping!
```

## Task 8: Invoking external program using system() versus execve()

Although `system()` and `execve()` can both be used to run new programs, `system()` is quite dangerous if used in a privileged program, such as Set-UID programs. We have seen how the PATH environment variable affect the behavior of `system()`, because the variable affects how the shell works. `execve()` does not have the problem, because it does not invoke shell. Invoking shell has another dangerous consequence, and this time, it has nothing to do with environment variables. Let us look at the following scenario.

Bob works for an auditing agency, and he needs to investigate a company for a suspected fraud. For the investigation purpose, Bob needs to be able to read all the files in the company’s Unix system; on the other hand, to protect the integrity of the system, Bob should not be able to modify any file. To achieve this goal, Vince, the superuser of the system, wrote a special set-root-uid program (see below), and then gave the executable permission to Bob. This program requires Bob to type a file name at the command line, and then it will run `/bin/cat` to display the specified file. Since the program is running as a root, it can display any file Bob specifies. However, since the program has no write operations, Vince is very sure that Bob cannot use this special program to modify any file.

```c
#include <string.h>
#include <stdio.h>
#include <stdlib.h>

int main(int argc, char *argv[])
{
    char *v[3];
    char *command;
    
    if(argc < 2) {
        printf("Please type a file name.\n");
        return 1;
    }

    v[0] = "/bin/cat"; v[1] = argv[1]; v[2] = NULL;
    
    command = malloc(strlen(v[0]) + strlen(v[1]) + 2);
    sprintf(command, "%s %s", v[0], v[1]);
    
    // Use only one of the followings.
    system(command);
    // execve(v[0], v, NULL);
    
    return 0;
}
```

### Step 1

Compile the above program, make root its owner, and change it to a Set-UID program. The program will use `system()` to invoke the command. If you were Bob, can you compromise the integrity of the system? For example, can you remove a file that is not writable to you?

```sh
[09/21/22]seed@VM:~$ vim task8.c
[09/21/22]seed@VM:~$ gcc task8.c -o task8
[09/21/22]seed@VM:~$ sudo chown root task8
[09/21/22]seed@VM:~$ sudo chmod 4755 task8
[09/21/22]seed@VM:~$ ls -la task8
-rwsr-xr-x 1 root seed 16928 Sep 21 13:54 task8
```

yes, we can remove, mv and others with root privileges if we run the above program, by:

./task8 "coba;mv coba coba_hacked"
by giving a semicolon to the filename and adding another new command.

```sh
[09/21/22]seed@VM:~$ echo "test" > coba
[09/21/22]seed@VM:~$ ./task8 "coba;mv coba coba_hacked"
test
[09/21/22]seed@VM:~$ ls
coba_hacked        mylib.c   res.out    task3.c  task8.c
Desktop            mylib.o   step1      task4    Templates
Documents          myprog    step1.c    task4.c  Videos
Downloads          myprog.c  task3      task5
libmylib.so.1.0.1  Pictures  task3_1    task5.c
Music              Public    task3_1.c  task8
[09/21/22]seed@VM:~$ ls coba*
coba_hacked
```

### Step 2

Comment out the `system(command)` statement, and uncomment the `execve()` statement; the program will use `execve()` to invoke the command. Compile the program, and make it Set-UID (owned by root). Do your attacks in Step 1 still work? 

```sh
[09/21/22]seed@VM:~$ ./task8-2 "coba;mv coba coba_2"
/bin/cat: 'coba;mv coba coba_2': No such file or directory
```
we can't attack.

## Task 9: Capability Leaking

To follow the Principle of Least Privilege, Set-UID programs often permanently relinquish their root privileges if such privileges are not needed anymore. Moreover, sometimes, the program needs to hand over its control to the user; in this case, root privileges must be revoked. The `setuid()` system call can be used to revoke the privileges. According to the manual, "`setuid()` sets the effective user ID of the calling process. If the effective UID of the caller is root, the real UID and saved set-user-ID are also set". Therefore, if a Set-UID program with effective UID 0 calls `setuid(n)`, the process will become a normal process, with all its UIDs being set to `n`.

When revoking the privilege, one of the common mistakes is capability leaking. The process may have gained some privileged capabilities when it was still privileged; when the privileged is downgraded, if the program does not clean up those capabilities, they may still be accessible by the non-privileged process. In other words, although the effective user ID of the process becomes non-privileged, the process is still privileged because it possesses privileged capabilities.

Compile the following program, change its owner to root, and make it a Set-UID program. Run the program as a normal user. Will the file `/etc/zzz` be modified?

```c
#include<stdio.h>
#include<stdlib.h>
#include<fcntl.h>

void main()
{
    int fd;
    
    // Assume that /etc/zzz is an important system file,
    // and it is owned by root with permission 0644.
    // Before running this program, you should creat
    // the file /etc/zzz first.
    fd = open("/etc/zzz", O_RDWR | O_APPEND);
    if(fd == -1) {
        printf("Cannot open /etc/zzz\n");
        exit(0);
    }
    
    // Simulate the tasks conducted by the program
    sleep(1);
    
    // After the task, the root privilege are no longer needed,
    // it's time to relinquish the root privileges permanently.
    setuid(getuid());   // getuid() returns the real uid
    
    if(fork()) {    // In the parent process
        close(fd);
        exit(0);
    } else {    // in the child process
        // Now, assume that the child process is compromised, malicious attackers
        // have injected the following statements into this process
        
        write(fd, "Malicious Data\n", 15);
        close(fd);
    }
}
```

Solution:
```sh
[09/21/22]seed@VM:~$ sudo su
root@VM:/home/seed# cd /etc
root@VM:/etc# nano task9.c
root@VM:/etc# vim task9.c
root@VM:/etc# gcc task9.c -o task9
task9.c: In function ‘main’:
task9.c:20:5: warning: implicit declaration of function ‘sleep’ [-Wimplicit-function-declaration]
   20 |     sleep(1);
      |     ^~~~~
task9.c:24:5: warning: implicit declaration of function ‘setuid’ [-Wimplicit-function-declaration]
   24 |     setuid(getuid());   // getuid() returns the real uid
      |     ^~~~~~
task9.c:24:12: warning: implicit declaration of function ‘getuid’ [-Wimplicit-function-declaration]
   24 |     setuid(getuid());   // getuid() returns the real uid
      |            ^~~~~~
task9.c:26:8: warning: implicit declaration of function ‘fork’ [-Wimplicit-function-declaration]
   26 |     if(fork()) {    // In the parent process
      |        ^~~~
task9.c:27:9: warning: implicit declaration of function ‘close’; did you mean ‘pclose’? [-Wimplicit-function-declaration]
   27 |         close(fd);
      |         ^~~~~
      |         pclose
task9.c:33:9: warning: implicit declaration of function ‘write’; did you mean ‘fwrite’? [-Wimplicit-function-declaration]
   33 |         write(fd, "Malicious Data\n", 15);
      |         ^~~~~
      |         fwrite
root@VM:/etc# chmod 4755 task9
root@VM:/etc# exit
exit
```
```sh
[09/21/22]seed@VM:/etc$ cat zzz
ni file penting
Malicious Data
```

Managed to write malicious data.
